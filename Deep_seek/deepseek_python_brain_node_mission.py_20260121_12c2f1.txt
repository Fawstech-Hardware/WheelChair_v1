import cv2
import numpy as np
import websocket
import threading
import time
import json
from enum import Enum
from collections import deque

# --- CONFIG ---
PHONE_IP = "192.168.0.105" 
VISION_URL = f"http://{PHONE_IP}:8080/video"
ACTUATOR_WS = "ws://192.168.0.118/ws"

# Navigation Tuning
X_CENTER = 320
STEER_DEADZONE = 70
STOP_AREA = 160000
HALLWAY_NAV_AREA = 80000  # Area threshold for hallway following
ROTATION_SPEED = 150
SEARCH_SPEED = 100
APPROACH_SPEED = 180

class Mode(Enum):
    MANUAL = "MANUAL CONTROL (Keyboard)"
    AUTO = "AUTONOMOUS (Mission)"
    CALIBRATE = "CALIBRATION MODE"

class RobotState(Enum):
    IDLE = "IDLE"
    SEARCHING = "SEARCHING"
    ALIGNING = "ALIGNING"
    FOLLOWING = "FOLLOWING"
    ROTATING = "ROTATING"
    ARRIVED = "ARRIVED"
    HAZARD = "HAZARD"
    LOST = "LOST"

# Location definitions (marker IDs)
class Locations(Enum):
    BEDROOM = 1
    HALLWAY = 3
    KITCHEN = 9
    BATHROOM = 5
    LIVING_ROOM = 7
    HAZARD = 0

class VideoStream:
    def __init__(self, url):
        self.cap = cv2.VideoCapture(url, cv2.CAP_FFMPEG)
        self.ret, self.frame = False, None
        self.running = True
        threading.Thread(target=self.update, daemon=True).start()
    
    def update(self):
        while self.running:
            self.ret, self.frame = self.cap.read()
    
    def read(self):
        if self.frame is not None:
            return self.ret, cv2.resize(self.frame, (640, 480))
        return False, None

class MissionManager:
    """Manages navigation sequences and path planning"""
    
    # Predefined routes (from -> to -> sequence of markers)
    ROUTES = {
        (Locations.BEDROOM, Locations.KITCHEN): [
            Locations.HALLWAY,
            Locations.KITCHEN
        ],
        (Locations.KITCHEN, Locations.BEDROOM): [
            Locations.HALLWAY,
            Locations.BEDROOM
        ],
        (Locations.BEDROOM, Locations.BATHROOM): [
            Locations.HALLWAY,
            Locations.BATHROOM
        ],
        (Locations.LIVING_ROOM, Locations.KITCHEN): [
            Locations.HALLWAY,
            Locations.KITCHEN
        ]
    }
    
    def __init__(self):
        self.current_location = Locations.BEDROOM  # Starting location
        self.destination = None
        self.mission_path = []  # List of Locations to follow
        self.current_target_idx = 0
        self.mission_active = False
        self.waypoint_reached = False
        
    def set_mission(self, destination):
        """Set a new mission to destination"""
        self.destination = destination
        route_key = (self.current_location, destination)
        
        if route_key in self.ROUTES:
            self.mission_path = self.ROUTES[route_key]
            print(f"üöÄ Mission Set: {self.current_location.name} ‚Üí {destination.name}")
            print(f"   Path: {' ‚Üí '.join([loc.name for loc in self.mission_path])}")
            self.current_target_idx = 0
            self.mission_active = True
            self.waypoint_reached = False
            return True
        else:
            print(f"‚ùå No known route from {self.current_location.name} to {destination.name}")
            return False
    
    def get_current_target(self):
        """Get the current target location in the mission"""
        if self.mission_active and self.current_target_idx < len(self.mission_path):
            return self.mission_path[self.current_target_idx]
        return None
    
    def complete_waypoint(self):
        """Mark current waypoint as reached and move to next"""
        if self.mission_active:
            completed = self.get_current_target()
            self.current_target_idx += 1
            self.waypoint_reached = True
            
            if self.current_target_idx >= len(self.mission_path):
                # Mission complete!
                self.current_location = self.destination
                self.mission_active = False
                print(f"üéâ Mission Complete! Arrived at {self.destination.name}")
                return True, None
            else:
                print(f"‚úÖ Waypoint reached: {completed.name}")
                print(f"   Next: {self.get_current_target().name}")
                return False, self.get_current_target()
        return False, None
    
    def abort_mission(self):
        """Abort current mission"""
        self.mission_active = False
        self.mission_path = []
        self.current_target_idx = 0
        print("‚ö†Ô∏è Mission Aborted")

class SmartBrain:
    def __init__(self):
        self.ws = None
        self.control_mode = Mode.MANUAL
        self.state = RobotState.IDLE
        self.last_cmd = "S"
        self.search_dir = "R"
        
        # Mission Management
        self.mission_mgr = MissionManager()
        self.current_target_id = None
        self.rotation_timeout = 0
        self.search_timeout = 0
        self.max_search_time = 5.0  # seconds
        self.rotation_start_time = 0
        
        # ArUco detection
        self.aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_50)
        self.aruco_params = cv2.aruco.DetectorParameters()
        self.detector = cv2.aruco.ArucoDetector(self.aruco_dict, self.aruco_params)
        
        # Statistics
        self.markers_detected = {}
        self.frame_count = 0
        
        self.connect_actuator()
        threading.Thread(target=self.heartbeat, daemon=True).start()
    
    def connect_actuator(self):
        try:
            self.ws = websocket.create_connection(ACTUATOR_WS, timeout=2)
            print("‚úÖ Actuator Connected")
        except Exception as e:
            print(f"‚ùå Actuator Offline: {e}")
    
    def heartbeat(self):
        while True:
            if self.ws:
                try:
                    self.ws.send(json.dumps({"cmd": "H"}))
                except:
                    pass
            time.sleep(0.1)
    
    def send_move(self, direction, speed):
        if direction != self.last_cmd:
            try:
                cmd = json.dumps({"cmd": "M", "dir": direction, "spd": speed})
                self.ws.send(cmd)
                self.last_cmd = direction
                print(f"[{self.state.value}] CMD: {direction}@{speed}")
            except Exception as e:
                print(f"‚ö†Ô∏è Send failed: {e}")
    
    def update_state(self, new_state):
        if self.state != new_state:
            print(f"üîÑ State: {self.state.value} ‚Üí {new_state.value}")
            self.state = new_state
    
    def detect_markers(self, gray_frame):
        """Detect ArUco markers and return processed data"""
        corners, ids, _ = self.detector.detectMarkers(gray_frame)
        markers = {}
        
        if ids is not None:
            for i, marker_id in enumerate(ids.flatten()):
                corners_i = corners[i][0]
                
                # Calculate marker center
                center_x = int((corners_i[0][0] + corners_i[1][0] + corners_i[2][0] + corners_i[3][0]) / 4)
                center_y = int((corners_i[0][1] + corners_i[1][1] + corners_i[2][1] + corners_i[3][1]) / 4)
                
                # Calculate area
                area = cv2.contourArea(corners_i)
                
                # Calculate orientation (simplified)
                dx = corners_i[1][0] - corners_i[0][0]
                dy = corners_i[1][1] - corners_i[0][1]
                angle = np.degrees(np.arctan2(dy, dx))
                
                markers[marker_id] = {
                    'center': (center_x, center_y),
                    'area': area,
                    'angle': angle,
                    'corners': corners_i
                }
                
                # Update statistics
                if marker_id not in self.markers_detected:
                    self.markers_detected[marker_id] = 0
                self.markers_detected[marker_id] += 1
        
        return markers
    
    def autonomous_navigation(self, frame, markers):
        """Execute mission-based autonomous navigation"""
        
        # 1. Check for hazards (highest priority)
        if 0 in markers:
            self.update_state(RobotState.HAZARD)
            self.send_move("S", 0)
            return
        
        # 2. Get current mission target
        target_loc = self.mission_mgr.get_current_target()
        if not target_loc:
            self.update_state(RobotState.IDLE)
            self.send_move("S", 0)
            return
        
        target_id = target_loc.value
        
        # 3. Check if target is visible
        if target_id in markers:
            marker_data = markers[target_id]
            center_x, center_y = marker_data['center']
            area = marker_data['area']
            
            # 4. State machine for target approach
            if area > STOP_AREA:
                # Target reached
                self.send_move("S", 0)
                mission_complete, next_target = self.mission_mgr.complete_waypoint()
                
                if mission_complete:
                    self.update_state(RobotState.ARRIVED)
                else:
                    self.update_state(RobotState.SEARCHING)
                    self.search_timeout = time.time()
            
            elif abs(center_x - X_CENTER) > STEER_DEADZONE:
                # Need to align
                self.update_state(RobotState.ALIGNING)
                if center_x < X_CENTER:
                    self.send_move("L", ROTATION_SPEED)
                    self.search_dir = "L"
                else:
                    self.send_move("R", ROTATION_SPEED)
                    self.search_dir = "R"
            
            else:
                # Aligned, approach target
                self.update_state(RobotState.FOLLOWING)
                
                # Special handling for hallway (ID 3) - follow until it's large
                if target_id == Locations.HALLWAY.value:
                    if area > HALLWAY_NAV_AREA:
                        # Hallway is large enough, go to next waypoint
                        self.mission_mgr.complete_waypoint()
                        self.update_state(RobotState.ROTATING)
                        self.send_move("R", ROTATION_SPEED)
                        self.rotation_start_time = time.time()
                    else:
                        # Continue following hallway
                        self.send_move("F", APPROACH_SPEED)
                else:
                    # Normal approach for other markers
                    self.send_move("F", APPROACH_SPEED)
        
        else:
            # Target not visible - search for it
            if self.state != RobotState.SEARCHING:
                self.update_state(RobotState.SEARCHING)
                self.search_timeout = time.time()
            
            # Check if we've been searching too long
            if time.time() - self.search_timeout > self.max_search_time:
                print("‚è∞ Search timeout - rotating")
                self.update_state(RobotState.ROTATING)
                self.send_move("R", ROTATION_SPEED)
                self.rotation_start_time = time.time()
                self.search_timeout = time.time() + 2.0  # Reset timeout
            else:
                # Continue searching in last direction
                self.send_move(self.search_dir, SEARCH_SPEED)
        
        # 5. Handle rotation state timeout
        if self.state == RobotState.ROTATING:
            if time.time() - self.rotation_start_time > 1.5:  # Rotate for 1.5 seconds
                self.update_state(RobotState.SEARCHING)
                self.send_move("S", 0)
                self.search_timeout = time.time()
    
    def process_frame(self, frame):
        """Process video frame and execute navigation logic"""
        self.frame_count += 1
        
        # Convert to grayscale for marker detection
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        
        # Detect markers
        markers = self.detect_markers(gray)
        
        # Draw HUD background
        cv2.rectangle(frame, (0, 0), (640, 120), (0, 0, 0), -1)
        
        # Mode and state display
        mode_color = (0, 255, 0) if self.control_mode == Mode.AUTO else (0, 165, 255)
        cv2.putText(frame, f"MODE: {self.control_mode.value}", (20, 30), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, mode_color, 2)
        cv2.putText(frame, f"STATE: {self.state.value}", (20, 60), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
        
        # Mission info
        if self.control_mode == Mode.AUTO and self.mission_mgr.mission_active:
            mission_text = f"MISSION: {self.mission_mgr.current_location.name} ‚Üí {self.mission_mgr.destination.name}"
            cv2.putText(frame, mission_text, (20, 90), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 1)
            
            if self.mission_mgr.get_current_target():
                target_text = f"TARGET: ID {self.mission_mgr.get_current_target().value} ({self.mission_mgr.get_current_target().name})"
                cv2.putText(frame, target_text, (20, 110), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)
        
        # Draw detected markers
        for marker_id, data in markers.items():
            center_x, center_y = data['center']
            area = data['area']
            
            # Draw marker center and ID
            cv2.circle(frame, (center_x, center_y), 5, (0, 255, 0), -1)
            cv2.putText(frame, f"ID:{marker_id}", (center_x + 10, center_y - 10), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)
            cv2.putText(frame, f"A:{int(area)}", (center_x + 10, center_y + 10), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.4, (200, 200, 200), 1)
            
            # Draw marker corners
            cv2.polylines(frame, [np.int32(data['corners'])], True, (255, 0, 0), 2)
        
        # Execute autonomous navigation if in AUTO mode
        if self.control_mode == Mode.AUTO:
            self.autonomous_navigation(frame, markers)
        
        # Draw center line and deadzone
        cv2.line(frame, (X_CENTER, 0), (X_CENTER, 480), (100, 100, 255), 1)
        cv2.line(frame, (X_CENTER - STEER_DEADZONE, 0), (X_CENTER - STEER_DEADZONE, 480), (100, 100, 100), 1)
        cv2.line(frame, (X_CENTER + STEER_DEADZONE, 0), (X_CENTER + STEER_DEADZONE, 480), (100, 100, 100), 1)
        
        # Frame counter
        cv2.putText(frame, f"Frame: {self.frame_count}", (500, 30), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.4, (150, 150, 150), 1)
        
        return frame

def main():
    vs = VideoStream(VISION_URL)
    brain = SmartBrain()
    
    print("\n" + "="*50)
    print("ü§ñ WHEELCHAIR MISSION CONTROL CENTER")
    print("="*50)
    print("\n--- CONTROLS ---")
    print("M: Toggle AUTO/MANUAL mode")
    print("1: Set mission to Kitchen")
    print("2: Set mission to Bedroom")
    print("3: Set mission to Bathroom")
    print("0: Abort current mission")
    print("W/A/S/D: Manual Movement")
    print("Q: Quit")
    print("\n--- LOCATIONS ---")
    for loc in Locations:
        print(f"  ID {loc.value}: {loc.name}")
    print("="*50 + "\n")
    
    while True:
        ret, frame = vs.read()
        if not ret:
            print("‚ö†Ô∏è No video feed")
            time.sleep(0.1)
            continue
        
        display_frame = brain.process_frame(frame)
        cv2.imshow("Wheelchair Mission Control", display_frame)
        
        key = cv2.waitKey(1) & 0xFF
        
        # Mode Toggle
        if key == ord('m'):
            if brain.control_mode == Mode.MANUAL:
                brain.control_mode = Mode.AUTO
                brain.update_state(RobotState.IDLE)
                print("üü¢ AUTO mode enabled")
            else:
                brain.control_mode = Mode.MANUAL
                brain.mission_mgr.abort_mission()
                brain.send_move("S", 0)
                print("üü° MANUAL mode enabled")
        
        # Mission Selection
        elif key == ord('1') and brain.control_mode == Mode.AUTO:
            if brain.mission_mgr.set_mission(Locations.KITCHEN):
                brain.update_state(RobotState.SEARCHING)
                brain.search_timeout = time.time()
        
        elif key == ord('2') and brain.control_mode == Mode.AUTO:
            if brain.mission_mgr.set_mission(Locations.BEDROOM):
                brain.update_state(RobotState.SEARCHING)
                brain.search_timeout = time.time()
        
        elif key == ord('3') and brain.control_mode == Mode.AUTO:
            if brain.mission_mgr.set_mission(Locations.BATHROOM):
                brain.update_state(RobotState.SEARCHING)
                brain.search_timeout = time.time()
        
        elif key == ord('0') and brain.control_mode == Mode.AUTO:
            brain.mission_mgr.abort_mission()
            brain.update_state(RobotState.IDLE)
            brain.send_move("S", 0)
        
        # Manual Controls (Only in MANUAL mode)
        if brain.control_mode == Mode.MANUAL:
            if key == ord('w'): brain.send_move("F", 200)
            elif key == ord('a'): brain.send_move("L", 150)
            elif key == ord('d'): brain.send_move("R", 150)
            elif key == ord('s'): brain.send_move("S", 0)
            elif key == ord('x'): brain.send_move("B", 150)
        
        # Quit
        if key == ord('q'):
            brain.send_move("S", 0)
            brain.mission_mgr.abort_mission()
            print("\nüìä Statistics:")
            for marker_id, count in brain.markers_detected.items():
                print(f"  ID {marker_id}: detected {count} times")
            break
    
    vs.running = False
    cv2.destroyAllWindows()
    print("‚úÖ System shutdown complete")

if __name__ == "__main__":
    main()